name: Deploy App to AWS

on:
  push:
    branches: [ main ]

jobs:
  # SCHRITT 1: Anwendung vorbereiten
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Node.js einrichten
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: app/package-lock.json

      - name: App bauen
        run: |
          cd app
          # Wir führen den Build durch
          npm ci
          npm run build

      - name: Artefakte hochladen
        uses: actions/upload-artifact@v4
        with:
          name: app-bundle
          # Wir nehmen den gesamten Ordner app, das ist sicherer
          path: app/
          include-hidden-files: true
          retention-days: 1

  # SCHRITT 2: Infrastruktur und Bereitstellung
  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Artefakte herunterladen
        uses: actions/download-artifact@v4
        with:
          name: app-bundle
          path: my-app-files # Wir laden in das Root-Verzeichnis des Runners herunter

      # Terraform auf dem Runner installieren
      - name: Terraform einrichten
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: AWS konfigurieren
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Terraform anwenden
        id: terraform
        run: |
          cd infra
          terraform init
          terraform apply -auto-approve -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"
          echo "SERVER_IP=$(terraform output -raw server_ip)" >> $GITHUB_ENV

      # --- HINZUGEFÜGTER SICHERHEITSSCHRITT ---
      - name: Warten, bis SSH bereit ist
        run: |
          echo "Warten auf SSH bei ${{ env.SERVER_IP }}..."
          timeout 300 bash -c 'until printf "" 2>>/dev/null >/dev/tcp/$0/22; do sleep 5; done' ${{ env.SERVER_IP }}
          echo "SSH ist bereit!"

      - name: Dateien auf EC2 kopieren
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          # QUELLE: Wir nehmen alles aus dem heruntergeladenen Ordner
          source: "my-app-files/"
          target: "/home/ubuntu/myapp"
          # Wir entfernen den Ordner 'my-app-files' beim Entpacken auf dem Server
          strip_components: 1
          # Wir schließen node_modules aus, um Beschädigungen zu vermeiden (image_2df270.png)
          rm: true

      - name: Anwendung starten
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/ubuntu/myapp

            # 1. Wir reinigen alles, um Modulkonflikte zu vermeiden (image_498e6f.png)
            pm2 delete next-app || true
            rm -rf node_modules

            # 2. Wir installieren die Abhängigkeiten ordnungsgemäß auf Linux AWS
            # Dies korrigiert den Fehler des nicht gefundenen Moduls und der Berechtigung
            npm install --production
            chmod -R +x node_modules/.bin

            # 3. Wir stellen sicher, dass der Build vorhanden ist (image_22faa1.png)
            if [ ! -d ".next" ]; then echo "❌ Fehler: .next fehlt"; exit 1; fi

            # 4. PM2 starten
            sudo npm install -g pm2
            pm2 start npm --name "next-app" -- start -- -H 0.0.0.0 -p 3000
            pm2 save
            
